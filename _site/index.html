<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Calliope by tuplejump</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Calliope</h1>
        <h2>Calliope provides a bridge between Cassandra and Spark framework allowing you to create those magical, realtime bigdata apps with ease!</h2>
        <a href="https://github.com/tuplejump/calliope" class="button"><small>View project on</small>GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
<h2>Why Cassandra + Spark?</h2>

<p>Cassandra + Spark is the match made in heaven! Spark with it&#39;s in memory mapreduce allows us to process data upto 10x faster than Hadoop MapReduce, opening doors to iterative map reduce, complex process chains in a plain and simple start and so much more. Spark did away with the complex setup and configuration required by Hadoop M/R in it&#39;s early days. Overall, it make big data crunching fun!</p>

<p>The only bottleneck now is the HDFS or worse HBASE, which are still used by many Spark developers to build the applications and providing a distributed data store to the RDDs. Setting up and maintaining HDFS and maintianing the cluster, requires effort and experience. All HDFS provides is a filesystem. Anything you put there is a file and will be read line by line. This may work for unstructured data, but not so much wth strutured one. The problem with both these solutions is htey are Hadoop! There I said it!!!</p>

<p>Come in Cassandra, built on Dynamo&#39;s gossip with BigTable&#39;s column oriented storage, Cassandra provides a resilient fualt tollerant robust very high speed data store. Coming from the NoSQL family of databses, it provides flexible schema support, which makes it good for structured as well as unstructured data. Setting up and managing Cassandra cluster&#39;s is quick and easy.</p>

<p>Cassandra storage bckend with Spark will open many new avenues.</p>

<h2>Why Calliope?</h2>

<p>Spark supports any Hadoop Input/Output provider and we know there is a Hadoop I/O for Cassandra, so I can simply use it! 
Yes, sure you can, and for now Calliope uses the same. But contrary to the Hadoop I/O API which was designed for java and Hadoop way of doing things, Calliope provides a improved cleaner API to create and persist RDDs, without exposing you to the internals. In furutre we would like to move away from Hadoop I/O here and build our own fat-free alternative. But, don&#39;t worry, we won&#39;t change the API for that.</p>

<h2>Enough, talk, show me the Code</h2>

<p>Here you go!</p>

<h3>Reading from Cassandra</h3>

<p>To read a <strong>Column Family</strong> names <em>Words</em> from a <strong>keyspace</strong> <em>casDemo</em> and create an RDD from it, here is the code required using Calliope, considering the <strong>key</strong> is a <em>String</em> and the <strong>row</strong> has all column names and values as <em>String</em>.</p>
<div class="highlight"><pre><code class="scala language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">com.tuplejump.calliope.RichByteBuffer._</span>
<span class="k">import</span> <span class="nn">com.tuplejump.calliope.Implicits._</span>
<span class="k">import</span> <span class="nn">com.tuplejump.calliope.CasBuilder</span>

<span class="k">val</span> <span class="n">cas</span> <span class="k">=</span> <span class="nc">CasBuilder</span><span class="o">.</span><span class="n">thrift</span><span class="o">.</span><span class="k">with</span><span class="o">(</span><span class="s">&quot;casDemo&quot;</span><span class="o">,</span> <span class="s">&quot;Words&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">rdd</span> <span class="k">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">cassandra</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">](</span><span class="kt">cas</span><span class="o">)</span>
</code></pre></div>
<p>And now you have a RDD[String, Map[String, String]]!</p>

<p>To fully appreciate the ease and terseness of the above code, I recomend you take a look at the the Cassandra example in Spark examples code.</p>

<h3>Writing to Cassandra</h3>

<p>To write an RDD[String, Map[String, String]] a <strong>Column Family</strong> names <em>Words</em> from a <strong>keyspace</strong> <em>casDemo</em> </p>
<div class="highlight"><pre><code class="scala language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">com.tuplejump.calliope.RichByteBuffer._</span>
<span class="k">import</span> <span class="nn">com.tuplejump.calliope.Implicits._</span>
<span class="k">import</span> <span class="nn">com.tuplejump.calliope.CasBuilder</span>

<span class="k">val</span> <span class="n">cas</span> <span class="k">=</span> <span class="nc">CasBuilder</span><span class="o">.</span><span class="n">thrift</span><span class="o">.</span><span class="k">with</span><span class="o">(</span><span class="s">&quot;casDemo&quot;</span><span class="o">,</span> <span class="s">&quot;Words&quot;</span><span class="o">)</span>
<span class="n">rdd</span><span class="o">.</span><span class="n">saveToCassandra</span><span class="o">(</span><span class="n">cas</span><span class="o">)</span>
</code></pre></div>
<h3>More examples</h3>

<p>See the test cases!</p>

<h2>Troubleshooting</h2>

<ul>
<li>Why do I get a &quot;No Implicit View Defined for X =&gt; Y&quot; message while compiling?</li>
</ul>

<p>Calliope relies on Implicits to convert to and from ByteBuffer and structures around it to Usable data types. In case you have a key or value type that doesn&#39;t have a implicit convertor defined, you will have to write one of your own. Don&#39;t worry this is easy, just look at the test cases.</p>

<ul>
<li>Why do I get a ByteBuffer not Serializable error while the computing on RDD created from Cassandra?</li>
</ul>

<p>You <strong>should</strong> give Type Parameters to sc.cassandra method and provide appropriate transformers for that.</p>

        </section>

        <aside id="sidebar">
          <a href="https://github.com/tuplejump/calliope/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/tuplejump/calliope/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="https://github.com/tuplejump/calliope"></a> is maintained by <a href="https://github.com/tuplejump">tuplejump</a>.</p>

        </aside>
      </div>
    </div>
    <footer>
	<div class="inner">
	<p>This page was generated by <a href="pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
	<p>Copyright 2013 &copy; Tuplejump Software Pvt. Ltd.</p>
	</div>
    </footer>

            <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-42063240-2");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
